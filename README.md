# common-x: *knowledge culture*

> *yeh-yeh, **finding** solutions (in problem-spaces) is cool... --but did you ever think about **growing** them?!*

---

## overview

This repository ~~describes~~ *will eventually describe*:-

1. a generalised approach & method for solving *"common-x"* type problems -- *(like "common-substring" and "common-subsequence")*

2. detail on approach & algorithmic extensibility *(& transformation)*, to handle different kinds of *"common-x"* problems

3. an account of the ways in which all "*problem-space problems*" are reformulable in terms of *"common-x"*; and a discussion on the approach and significance of reformulating problems to *"well-formed commmon-x"*

4. a discussion on the *"ideal form"* of common-x solutions, including data-structures & hardware

> Links:
> - [Practical demonstration](./src/main.ts)
> 
> Solvers:
>  - [Brute Force Runner](./src/runners/bruteForceRunner.ts) | [Brute Force Solver](./src/solvers/BruteForceSolver.ts)
>  - [Constituient Runner](./src/runners/constituientRunner.ts) | [Solver](./src/solvers/ConstituientSolver.ts)
>  - [Cultivated Runner](./src/runners/cultivatedRunner.ts) | [Solver](./src/solvers/CultivatedSolver.ts)
>  - [Deductive Runner](./src/runners/deductiveRunner.ts) | [Solver](./src/solvers/DeductiveResolver.ts)
>  - [(Lazy Fake) Suffix-Tree Runner](./src/runners/lazyFakeSuffixTreeRunner.ts) | [(Lazy Fake) Suffix-Tree Solver](./src/solvers/LazyFakeSuffixTreeSolver.ts)
>  - [Positive Projection Runner](./src/runners/projectionSolver.ts) | [Positive Projection Solver](./src/solvers/ProjectionSolver.ts)

---

## introduction
> *common-x: knowledge-culture*

So, it turns out that we can reformulate some *"finding things, in spaces"* type-problems, to *"growing things, in spaces"* type-problems *(--which is interesting, right?!)*

> for intuition, think of the difference between recall and derivation -- *(the difference between being told something to remember (like LLMs, say); and independently working things out from "first-principles")*

Like independent derivation, we can grow solutions *(to problem-space type problems)* piece-by-piece: from first-principles, to final structural form; and all without being told what to look for -- without knowing in advance the *"special-domain structural forms" (which are subsequently grown)*

> for intuition, think of intellectual/cognitive creativity & insight -- *the genesis of new domains of knowledge*

More than the difference between recall & derivation, perhaps the most apt analogy for this kind of *"remarkably organic"* problem-solving, is biological-growth: specifically, when we want to artificially engineer *(only very simple)* biological-form, we must first isolate and prepare a special environment, free from pollutants, full of all of the *"right kinds"* of ingredients *(chemical & biological)* *"pieces"* from which the intended forms will grow; and this is exactly what must be done to *"grow solutions to problem-space problems"* we must first identify and isolate only the right kinds of *"ingredients"* from which the form of the final solution will grow...

...like a petri-dish in a laboratory environment...

...but within the entirely abstract domain of *"information"*...

Knowledge, it seems, is like a crop; and must be cultivated.

Learning, it seems, depends upon situationally appropriate *"knowledge culture"*, from which "structural representational forms" are cultivated, and grown to maturity; and just like physical-crops *(in reality)*, it is sometimes quicker and easier to cultivate and grow crops, than find the same volume, arbitrarily distributed throughout some terrain...

Wild, right?

> indeed, with the [Cultivated Solver](./src/runners/cultivatedRunner.ts), might we be looking at ***the domestication of "wild-knowledge"***, cultivated and grown *(farmed?!)*, within abstract realms...

> tbc

---


...


